{"name":"Rivus CEP","tagline":"Complex event processing in Erlang","body":"[![Build Status](https://travis-ci.org/vascokk/rivus_cep.png)](https://travis-ci.org/vascokk/rivus_cep)\r\n\r\n#Rivus CEP\r\n\r\nRivus CEP is an Erlang library for complex event processing. It uses a declarative SQL-like DSL for processing the events.\r\n\r\nWith Rivus you can do things like:\r\n\r\n```\r\nselect \r\n    ev1.eventparam1, ev2.eventparam2, sum(ev2.eventparam3) \r\nfrom \r\n    event1 as ev1, event2 as ev2\r\nwhere \r\n    ev1.eventparam2 = ev2.eventparam2\r\nwithin 60 seconds\r\n```\r\n\r\nor 'select' events from pattern:\r\n\r\n``` \r\nselect \r\n    ev1.eventparam1, ev2.eventparam2, ev2.eventparam3, ev2.eventparam4\r\nfrom \r\n    event1 as ev1 -> event2 as ev2\r\nwhere\r\n    ev1.eventparam2 = ev2.eventparam2\r\nwithin 60 seconds\r\n```\r\n\r\nIn the second query, the result will be generated only in case when event2 stricltly follows event1, within a 60 seconds window.\r\n\r\nHere is how to use it:\r\n\r\n``` erlang\r\napplication:start(rivus_cep)\r\n\r\nQueryStr = \"define correlation2 as\r\n                  select ev1.eventparam1, ev2.eventparam2, sum(ev2.eventparam3) \r\n                  from event1 as ev1, event2 as ev2\r\n                   where ev1.eventparam2 = ev2.eventparam2\r\n                    within 60 seconds; \"\r\n\r\nProducer = event_producer_1,\r\n{ok, SubscriberPid} = result_subscriber:start_link(), \r\n\r\n{ok, QueryPid} = rivus_cep:load_query(test_query, QueryStr, [Producer], [SubscriberPid]),\r\n    \r\n%% create some evetnts\r\nEvent1 = {event1, gr1,b,10}, \r\nEvent2 = {event2, gr2,bbb,20},\r\n\r\n%% send the events\r\nrivus_cep:notify(Producer, Event1),\r\nrivus_cep:notify(Producer, Event2).\r\n\r\n%% or if you don't care about the producers\r\nrivus_cep:notify(Event1),\r\nrivus_cep:notify(Event2).\r\n\t\r\n```\r\n\r\nThe query is started with `rivus_cep:load_query/4`. It takes as arguments: query name, query string, list of event producers and list of query result subscribers.\r\n\r\nEach query worker will register itself to the  [gproc](https://github.com/uwiger/gproc) process registry, for the events listed in the \"from\" clause.\r\n\r\nIf the events are sent via `rivus_cep:notify/1`, the event will be received by any query subscribed for this event type. With `notify/2` - only the queries subscribed to the particular Producer will receive the event.\r\n\r\nFor each query there must be at least one Subscriber to receive the query results.\r\n\r\nSee `tests/rivus_cep_tests.erl` for more usage examples. \r\n\r\nInternally, the events are stored in an ETS-based sliding window. DSL statments are translated to Erlang \"match specifications\" and QLC queries.\r\n\r\nFor each event type there must be a module implementing the `event_behavior` with the same name used in the \"from\" clause. The important function that needs to be implemented is - `get_param_by_name(Event, ParamName)`. \r\n\r\nSee some DSL examples in `test/rivus_cep_parser_tests.erl`.\r\n\r\n###Dependencies\r\n\r\n- [gproc](https://github.com/uwiger/gproc)\r\n- [folsom](https://github.com/boundary/folsom)\r\n- [lager](https://github.com/basho/lager)\r\n\r\n###Current limitations\r\n\r\nThe project is in its infancy and there is a number of limitations/TODOs:\r\n\r\n- each query has its own events 'reservoir' (not quite memory efficient)\r\n- more aggregation functions are yet to be implemented;\r\n- using event aliases is mandatory;\r\n- only sliding windows are supported (no 'batch' windows);\r\n- no benchmarks at all;\r\n- extensive testing needed.\r\n\r\n###Contributions\r\n\r\nContributions and suggestions are most appreciated!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}