%% ; -*- mode: Erlang;-*-
%%------------------------------------------------------------------------------
%% Copyright (c) 2013 Vasil Kolarov
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%------------------------------------------------------------------------------

-module( {{stmtName}} ).

-behaviour(gen_server).

-compile([{parse_transform, lager_transform}]).
-compile({parse_transform,ms_transform}).
-compile({parse_transform,qlc}).

-export([init/1, handle_cast/2, handle_call/3, handle_info/2, code_change/3, terminate/2]).
-export([start_link/2]).

-record(state_data,{
	  producers,
	  subscribers,
	  events = [ {{ eventList|join:", " }} ] ,
	  timeout = {{ timeout }},
	  output = []
}).

%%% API functions

start_link(Producers, Subscribers) ->
    gen_server:start_link( {{stmtName}}, [Producers, Subscribers, #state_data{}], []).

init([Producers, Subscribers, StateData]) ->
    rivus_cep_window:new( {{stmtName}}, slide, {{timeout}} ),
    [ gproc:reg({p, l, {Producer, Event }}) || Producer<-Producers, Event<-StateData#state_data.events],
    %% for eventName in eventList %}
    %% [gproc:reg({p, l, {Owner, {{eventName}} } }),
    %% endfor %}
    %%%%gproc:reg({p, l, get_result}),
    lager:debug("~nStarting: {{stmtName}}, PID: ~p ~n",[self()]),
    {ok, #state_data{producers = Producers, subscribers = Subscribers}}.


create_match_spec(Event, Oldest) ->
    ets:fun2ms(fun({ {Time,'_'},Value}) when Time >= Oldest andalso element(1,Value)==Event  -> Value end).
    
    
create_from_qh(MatchSpec, Reservoir) ->
     ets:table(Reservoir, [{traverse, {select, MatchSpec}}]).

send_result(StateData) ->

    {Reservoir, Oldest} = rivus_cep_window:get_window( {{stmtName}} ),
    MatchSpecs = [create_match_spec(Event, Oldest) || Event<- StateData#state_data.events],
    FromQueryHandlers = [create_from_qh(MS, Reservoir) || MS <- MatchSpecs],
    
    {{resultsetStmt}}
 
    ResultSet = qlc:e(QH),    

    lager:debug("---> Result Set: ~p", [ResultSet]),

    case ResultSet of
	[] -> nil;
	_ -> begin
		 FirstRec = hd(ResultSet),
		 Key = rivus_cep_aggregation:get_group_key(FirstRec),
		 
		 Result = case length(tuple_to_list(FirstRec)) == length(tuple_to_list(Key)) of
			      true -> ResultSet; %% no aggregations in the 'select' stmt
			      false -> rivus_cep_aggregation:eval_resultset(test_stmt, ResultSet, rivus_cep_aggregation:new_state())
			  end,
		 lager:debug("---> Result: ~p <-----", [Result]),
		 
		 [gproc:send({p, l, {Subscriber, result_subscribers}}, Result) || Subscriber<-StateData#state_data.subscribers]
	     end
    end.

	
handle_call(Request, From, StateData) ->
    Reply = {ok, notsupported} ,
    {reply, Reply, StateData}.

handle_cast(Msg, StateData) ->
    {noreply, StateData}.


{% for eventName in eventList %}
handle_info({ {{ eventName }} , Event}, StateData) ->
    lager:debug("handle_info Event: ~p",[Event]),
    rivus_cep_window:update( {{stmtName}}, Event),
    send_result(StateData),
    {noreply, StateData};    
{% endfor %}
handle_info(Info, StateData) ->
    lager:debug("StateDatament: ~p,  handle_info got event: ~p. Will do nothing ...",[ {{stmtName}} ,Info]),
    {noreply, StateData}.

terminate(Reason, StateData) ->
    ok.

code_change(OldVsn, StateData, Extra) ->
    {ok, StateData}.
