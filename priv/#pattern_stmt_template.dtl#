%% ; -*- mode: Erlang;-*-
%%------------------------------------------------------------------------------
%% Copyright (c) 2013 Vasil Kolarov
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%------------------------------------------------------------------------------

-module( {{stmtName}} ).

-behaviour(gen_fsm).

-compile([{parse_transform, lager_transform},
	  {parse_transform, ms_transform},
	  {parse_transform, qlc}]).

-export([init/1, handle_info/3, handle_event/3, handle_sync_event/4, code_change/4, terminate/3]).
-export([start_link/2]).

-record(state_data,{
	  producers,
	  subscribers,
	  events = [ {{ eventList|join:", " }} ] ,
	  timeout = {{ timeout }},
	  output = []
}).

start_link(Producers, Subscribers) ->
    gen_fsm:start_link( {{stmtName}}, [Producers, Subscribers, #state_data{}], []).

init([Producers, Subscribers, StateData]) ->
    [ gproc:reg({p, l, {Producer, Event }}) || Producer<-Producers, Event<-StateData#state_data.events],
    %% for eventName in eventList %}
    %%   gproc:reg({p, l, {Owner, {{eventName}} } }),
    %% endfor %}
    
    lager:debug("~nStarting: {{stmtName}}, PID: ~p ~n",[self()]),
    new_window(),  
    %%gen_fsm:start_timer(StateData#state_data.timeout, new_time_window),  
    {ok, {{ eventList|first }} , #state_data{producers = Producers, subscribers = Subscribers}}.

%% Internal functions
send_result(State) ->
    {Reservoir, Oldest} = rivus_cep_window:get_window( State#state.query_name ),
    MatchSpecs = [create_match_spec(Event, Oldest) || Event<- State#state.events],
    QueryHandlers = [create_qh(MS, Reservoir) || MS <- MatchSpecs],

    PreResultSet = [qlc:e(QH) || QH <- QueryHandlers ],    
 
    lager:debug("---> Pre-Result Set: ~p", [PreResultSet]),

    CartesianRes = lists:foldl(fun(Xs, A) -> [[X|Xs1] || X <- Xs, Xs1 <- A] end, [[]], PreResultSet),

    lager:debug("---> Result Set Cartesian: ~p", [CartesianRes]),

    WhereClause = (State#state.query_ast)#query_ast.where,
    SelectClause = (State#state.query_ast)#query_ast.select,
    
    FilteredRes = [ResRecord || ResRecord <- CartesianRes, where_eval(WhereClause, ResRecord) ],
    
    lager:debug("---> Filtered Result: ~p", [FilteredRes]),

    ResultSet = [list_to_tuple(build_select_clause(SelectClause, ResRecord,  [])) || ResRecord <-FilteredRes],

    lager:debug("---> ResultSet: ~p", [ResultSet]),
    
    case ResultSet of
    	[] -> nil;
    	_ -> FirstRec = hd(ResultSet),
	     Key = rivus_cep_aggregation:get_group_key(FirstRec),
	     %%naive check for aggregations in the select clause:
	     Result = case length(tuple_to_list(FirstRec)) == length(tuple_to_list(Key)) of
			  true -> ResultSet; %% no aggregations in the 'select' stmt
			  false -> rivus_cep_aggregation:eval_resultset(test_stmt, ResultSet, rivus_cep_aggregation:new_state())
		      end,
	     lager:debug("---> Result: ~p <-----", [Result]),
	     [gproc:send({p, l, {Subscriber, result_subscribers}}, Result) || Subscriber<-State#state.subscribers]
    end.

create_match_spec(Event, Oldest) ->
    ets:fun2ms(fun({ {Time,'_'},Value}) when Time >= Oldest andalso element(1,Value)==Event  -> Value end).
    
    
create_qh(MatchSpec, Reservoir) ->
     ets:table(Reservoir, [{traverse, {select, MatchSpec}}]).

where_eval({Op, Left, Right}, ResRecord) ->
    case Op of
	'and' -> where_eval(Left, ResRecord) andalso where_eval(Right, ResRecord);
	'or' -> where_eval(Left, ResRecord) orelse where_eval(Right, ResRecord);
	eq -> where_eval(Left, ResRecord) ==  where_eval(Right, ResRecord) ;
	gt -> where_eval(Left, ResRecord) > where_eval(Right, ResRecord); 
	plus -> where_eval(Left, ResRecord) + where_eval(Right, ResRecord);
	minus -> where_eval(Left, ResRecord) - where_eval(Right, ResRecord)
    end;
where_eval({Type, Value}, ResRecord) ->
    case Type of
	integer -> Value;
	float -> Value;
	EventName -> Event = lists:keyfind(EventName,1,ResRecord),
		     (EventName):get_param_by_name(Event,Value)

    end.

select_eval({integer, Value}, _) ->
     Value;
select_eval({float, Value}, _) ->
    Value;
select_eval({EventName,ParamName}, ResRecord) when not is_tuple(EventName) andalso not is_tuple(ParamName)->
    Event = lists:keyfind(EventName,1,ResRecord),
    EventName:get_param_by_name(Event, ParamName);
select_eval({sum,SumTuple}, ResRecord) ->
    {sum,{select_eval(SumTuple, ResRecord)}}; 
select_eval({avg,AvgTuple}, ResRecord) ->
    {avg, {select_eval(AvgTuple, ResRecord)}}; 
select_eval({count,CountTuple}, ResRecord) ->
    {count,{select_eval(CountTuple, ResRecord)}}; 
select_eval({min,MinTuple}, ResRecord) ->
    {min,{select_eval(MinTuple, ResRecord)}};
select_eval({max,MaxTuple}, ResRecord) ->
    {max,{select_eval(MaxTuple, ResRecord)}};
select_eval({Op,Left,Right}, ResRecord) ->
     {Op,{select_eval(Left, ResRecord)},select_eval(Right, ResRecord)}.

build_select_clause([H|T], EventList, Acc) ->
     build_select_clause(T, EventList, Acc ++ [select_eval(H, EventList)]);
build_select_clause([], _, Acc) ->
     Acc.

new_window() ->
    rivus_cep_window:new( {{ stmtName }}, slide, {{ timeout }} ).

%% FSM state functions

{% for eventName in eventList %}
{{eventName}}(timeout, StateData) ->
    lager:debug("State: ~p got timeout. ",[{{eventName}}]),
    new_window(),
    {next_state, {{ eventList|first }} ,  StateData};
{{eventName}}({ timeout, Ref, Msg}, StateData) ->
    lager:debug("State: ~p got timeout with Msg: ~p",[{{eventName}}, Msg]),
    new_window(),
    {next_state, {{ eventList|first }} ,  StateData}.		  
{% endfor %}



%% gen_fsm functions

{% for eventName in eventList %}
handle_info({ {{ eventName }} , Event}, {{ eventName }} , StateData) ->
    lager:debug("handle_info Event: ~p",[Event]),
    rivus_cep_window:update( {{stmtName}}, Event),
    %%gen_fsm:send_event( {{ eventName }}, Event ),
    {% if forloop.last  %}
        send_result(StateData),
        {next_state, {{ eventList|first }} ,  StateData};
    {% else %}
        {next_state, {{ eventList|next:forloop.counter }} ,  StateData};
    {% endif %}
{% endfor %}
handle_info(Info, StateName, StateData) ->
    lager:debug("Statement: ~p,  handle_info got event: ~p in state: ~p. Will do nothing ...",[ {{stmtName}} ,Info, StateName]),
    new_window(),
    {next_state, {{ eventList|first }}, StateData}.

handle_event(Event, StateName, StateData) ->
    lager:debug("Statement: ~p,  handle_event got event: ~p in state: ~p. Will do nothing ...",[ {{stmtName}} ,Event, StateName]),
    new_window(),
    {next_state, {{ eventList|first }}, StateData}.

handle_sync_event(Event, From, StateName, StateData) ->
    lager:debug("Statement: ~p,  handle_sync_event got event: ~p in state: ~p. Will do nothing ...",[ {{stmtName}} ,Event, StateName]),
    new_window(),
    {next_state, {{ eventList|first }}, StateData}.

terminate(Reason, StateName, StateData) ->
    ok.

code_change(OldVsn, StateName, StateData, Extra) ->
    {ok, StateName, StateData}.
